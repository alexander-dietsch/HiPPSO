<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>High Precision PSO: High Precision Particle Swarm Optimization (HiPPSO) in C++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">High Precision PSO
   </div>
   <div id="projectbrief">High Precision Particle Swarm Optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">High Precision Particle Swarm Optimization (HiPPSO) in C++ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Table of Contents</h2>
<ul>
<li><a href="#high-precision-particle-swarm-optimization-hippso-in-c">High Precision Particle Swarm Optimization (HiPPSO) in C++</a></li>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#description">Description</a></li>
<li><a href="#features">Features</a></li>
<li><a href="#installation-instructions">Installation Instructions</a><ul>
<li><a href="#installation-on-windows">Installation on Windows</a></li>
<li><a href="#installation-on-a-linux-operating-system">Installation on a Linux operating system</a></li>
</ul>
</li>
<li><a href="#usage">Usage</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#feedback">Feedback</a></li>
<li><a href="#license">License</a></li>
<li><a href="#scientific-results">Scientific Results</a></li>
<li><a href="#references">References</a></li>
</ul>
<h2>Description</h2>
<p>The High Precision Particle Swarm Optimization (HiPPSO) is an implementation of the particle swarm optimization (PSO) with highly precise data types.</p>
<p>PSO is a popular nature inspired meta heuristic for solving PSO, introduced by Kennedy and Eberhart [1,2], is a very popular nature-inspired meta-heuristic for solving continuous optimization problems. It is inspired by the social interaction of individuals living together in groups and supporting and cooperating with each other. It is applied to continuous objective functions on a multi-dimensional domain. Those functions are likely not given in a closed form, but by a <em>black box</em>. The popularity of the PSO framework is due to the fact that on the one hand it can be realized and, if necessary, adapted to further needs easily, but on the other hand shows in experiments good performance results with respect to the quality of the obtained solution and the speed needed to obtain it. A thorough discussion of PSO can be found in [3].</p>
<p>To be precise, let an objective function f:IR<sup>D</sup>&rarr;IR on a D-dimensional domain be given that (w. l. o. g.) has to be minimized. A population of <em>particles</em>, each consisting of a position (the candidate for a solution), a velocity and a local attractor, moves through the search space IR<sup>D</sup>. The local attractor of a particle is the best position with respect to f this particle has encountered so far. The best of all local attractors is the global attractor. The movement of a particle is governed by so-called movement equations that depend on both the particle's velocity and its two attractors and on some additional fixed algorithm parameters.</p>
<h2>Features</h2>
<p>The key feature of this implementation is the usage of data types with arbitrary precision. Those data types are used for all relevant calculations. Here the precision is meant as the number of bits of the mantissa of the floating point data type. Either the precision can be set to a fixed value or the precision can be set adjustable. If the precision is set adjustable, then the software autonomously increases the precision to avoid errors related to imprecise evaluations. With this implementation one can get as close to actual real numbers as possible.</p>
<p>In addition this software is highly adaptable. Many options for the particle swarm are already implemented. There are a plenty of already defined objective functions, neighborhood topologies and bound handling strategies. For analysis of the particle swarm there are also a plenty of statistical evaluations, which can be displayed. Furthermore the objective functions and the statistical evaluations are highly modularized to enable the user to specify them on demand.</p>
<p>If the available options are not sufficient, then it is possible to implement further possibilities (Further objective functions, neighborhood topologies, statistical evaluations, bound handling strategies, velocity adjustment strategies, position and velocity update procedures, ...). Only the respective interfaces need to be implemented and then new idea can be added to the available features and used. Here the arbitrary precision data type needs to be used, but to ease this process a large set of operations on this data type is already implemented.</p>
<h2>Installation Instructions</h2>
<h3>Installation on Windows</h3>
<ul>
<li>Install Cygwin with components gcc, m4 and make</li>
<li>Install the GMP library<ul>
<li>Download and unzip the GMP sources and switch to that folder.<ul>
<li>For example: download <code>gmp-x.x.x.tar.xz</code> from <a href="https://gmplib.org/">https://gmplib.org/</a></li>
<li>unzip the file with <code>tar -xJf gmp-x.x.x.tar.xz</code></li>
<li>go to that folder with <code>cd gmp-x.x.x</code></li>
</ul>
</li>
<li>Execute <code>./configure</code></li>
<li>Execute <code>make</code></li>
<li>Execute <code>make install</code></li>
<li>It might be necessary to copy the library <code>libgmp.a</code> and <code>libgmp.la</code> from <code>/usr/local/lib</code> to <code>/lib</code> to ensure that it is recognized.</li>
</ul>
</li>
<li>Download and unzip the High Precision PSO sources and switch to that folder.</li>
<li>Execute <code>make</code> to generate the executable file (<code>high_precision_pso.exe</code>).</li>
<li>The executable file can be moved to any location - it contains the whole program. For example you can move it to a folder, which is included in your PATH variable. If you do this you can start the High Precision PSO program at any location without prefix.</li>
</ul>
<h3>Installation on a Linux operating system</h3>
<ul>
<li><p class="startli">Install g++ compiler, and make (if not already present).</p>
<p class="startli">On systems like Ubuntu you can install them by the command <code>sudo apt-get install make g++</code>.</p>
</li>
<li>Install the GMP library<ul>
<li>On systems like Ubuntu you can install the GMP library by the command <code>sudo apt-get install libgmp-dev</code>.</li>
<li>Alternatively you can install it as described in the Windows section.</li>
</ul>
</li>
<li>Download and unzip the High Precision PSO sources and switch to that folder.</li>
<li>Execute <code>make</code> to generate the executable file (<code>high_precision_pso</code>).</li>
<li>The executable file can be moved to any location - it contains the whole program. For example you can move it to a folder, which is included in your PATH variable. If you do this you can start the High Precision PSO program at any location without prefix.</li>
</ul>
<h2>Usage</h2>
<p>The program is a command line tool. If the program is started without any parameters, then the available options will be displayed.</p>
<p>The behavior is specified in a configuration file. Examples and explanations of all options, which can be used in the configuration files, can be found in the sub-folder <code>guideline_configuration_files</code>. An exception is the file <code>runcheck.conf</code>. If the runcheck option is activated in the normal configuration files, then it can be specified, when the program is allowed to run. As the runcheck configuration file is parsed multiple times this can be used to terminate the program without losing any information.</p>
<p>Usually the High Precision PSO program is started with parameter <code>c</code> and the name of the configuration file. For example to start the HiPPSO with the example configuration file one can use </p><pre class="fragment">./high_precision_pso c guideline_configuration_files/example_configuration_file.conf
</pre><p>The HiPPSO generates various files. At the start it generates a configuration backup file (extension <code>confBU</code>), which stores the chosen configuration. Also at the start a log file (extension <code>log</code>) is created, which stores when the HiPPSO starts / stops / restarts / finishes simulation of the particle swarm. Approximately each minute (and at clean termination) a data backup file (extension <code>backup</code>) is generated, which stores all information about the current state such that it can be recovered. Additionally for each specified statistic a data file will be generated, which contains the evaluated statistical data. If also the debug swarm directive is activated in the configuration file, then an additional folder is created with the name of the prefix of the other files. In this folder gnuplot input files are created and a script to create images out of them. gnuplot needs to be installed to generate images.</p>
<p>If the HiPPSO is terminated by the runcheck configuration file, then it can be restarted with parameter <code>r</code> and the name of the configuration backup file, which has extension <code>confBU</code>.</p>
<p>If the HiPPSO has been illegally terminated, then one can try to restart with parameter <code>rf</code> and the name of the configuration backup file, which has extension <code>confBU</code>.</p>
<p>Additionally the HiPPSO can restart with a configuration file and a data backup file. For this purpose one can use the parameter <code>restart</code> followed by the name of the configuration file followed by the name of the data backup file. This option might be useful if you like to increase the number of iterations, or change the statistical evaluations. The HiPPSO will then start the simulation at the stored iteration in the data backup file.</p>
<h2>Examples</h2>
<p>In the examples folder some examples can be found.</p>
<p><code>example_01</code> starts a particle swarm with four particles on the sphere function (f(x)=&sum;<sub>d=0..D-1</sub>x[d]<sup>2</sup>) in two dimensions. The used configuration file is <code>example_01.conf</code>. A statistic is generatet, which contains the objective function value of the best found position. In combination with the short gnuplot script <code>example_01.STAT.GlBestFuncValue.gnuplot.txt</code> the following figure can be produced:</p>
<div class="image">
<img src="example_01.STAT.GlBestFuncValue.png" alt="example_01.STAT.GlBestFuncValue.png"/>
<div class="caption">
trend of the objective function value of the best found position</div></div>
<p> Additionally the debug swarm directive created a folder with gnuplot scripts. After executing the script the images look like this:</p>
<div class="image">
<img src="example_01.animation.gif" alt="example_01.animation.gif"/>
<div class="caption">
particles and attractors</div></div>
<p> (This gif is produced by the command <code>convert -delay 50 -loop 0 *.png \( +clone -set delay 500 \) +swap +delete animation.gif</code> in the folder of the generated png files)</p>
<p>But even in higher dimensions the swarm can be displayed very well by this software. <code>example_02</code> starts a particle swarm with eight particles on the sphere function (f(x)=&sum;<sub>d=0..D-1</sub>x[d]<sup>2</sup>) in eight dimensions. The used configuration file ist <code>example_02.conf</code>. The debug swarm directive created a folder with gnuplot scripts. After executing the script the images look like this:</p>
<div class="image">
<img src="example_02.animation.gif" alt="example_02.animation.gif"/>
<div class="caption">
particles and attractors</div></div>
<p> (This gif is produced by the command <code>convert -delay 100 -loop 0 *.png \( +clone -set delay 500 \) +swap +delete -resize 50% animation.gif</code> in the folder of the generated png files)</p>
<p>If this visualization is not suitable, then the bare data of particle positions, local and global attractor positions, velocities and anything else can be extracted by statistics. Through this statistics everyone can display the data in the preferred way.</p>
<p>The explicit advantage of this software is the opportunity to activate self adjusting precision. <code>example_03</code> displays the developement of the global attractor value of the HiPPSO optimizing the three-dimensional Rosenbrock function (f(x)=&sum;<sub>d=0..D-2</sub>(100(x[i+1]-x[i]<sup>2</sup>)<sup>2</sup>+(1-x[i])<sup>2</sup>) ) with four particles. The used configuration files are <code>example_03a.conf</code> (configuration with self adjusting precision) and <code>example_03b.conf</code> (configuration with constant precision). A statistic is generatet, which contains the objective function value of the best found position. In combination with the short gnuplot script <code>example_03.STAT.GlBestFuncValue.gnuplot.txt</code> the following figure can be produced:</p>
<div class="image">
<img src="example_03.STAT.GlBestFuncValue.png" alt="example_03.STAT.GlBestFuncValue.png"/>
<div class="caption">
trend of the objective function value of the best found position</div></div>
<p> This image visualizes the limitations of constant precision, which is present in usual floating point calculations, compared to the actual behaviour. As the position differences become small the actual differences can not be stored correctly to ensure correct transformation of the mathematical idea of PSO to the actual optimization procedure. This results in a situation where optimization is stopped completely. Therefore it is obvious that using larger precision is essential to produce reliable examples. Furthermore HiPPSO automatically increases precision on demand, which saves runtime on earlier iterations, when lower precision is sufficient.</p>
<h2>Documentation</h2>
<p>The documentation including an API can be found on <a href="https://alexander-rass.github.io/HiPPSO/">https://alexander-rass.github.io/HiPPSO/</a></p>
<h2>Feedback</h2>
<p>Please feel free to contact Alexander Raß (<a href="#" onclick="location.href='mai'+'lto:'+'Ale'+'xa'+'nde'+'r.'+'Ras'+'s@'+'fau'+'.d'+'e'; return false;">Alexa<span style="display: none;">.nosp@m.</span>nder<span style="display: none;">.nosp@m.</span>.Rass<span style="display: none;">.nosp@m.</span>@fau<span style="display: none;">.nosp@m.</span>.de</a>). Feedback or a notice that you use this program is highly appreciated. We will also support you in case you have problems during installation or usage of this program.</p>
<h2>License</h2>
<p>The MIT License (MIT)</p>
<p>Copyright (c) 2016 by Friedrich-Alexander-Universität Erlangen-Nürnberg and Alexander Raß and Manuel Schmitt</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<p>See also the <a class="el" href="md_LICENSE.html">license file</a></p>
<h2>Scientific Results</h2>
<p>The following paper uses HiPPSO for experiments:</p>
<p>Raß A., Schmitt M., Wanka R.: <br />
 Explanation of Stagnation at Points that are not Local Optima in Particle Swarm Optimization by Potential Analysis <br />
 17th Genetic and Evolutionary Computation Conference (GECCO) <br />
 DOI: 10.1145/2739482.2764654</p>
<h2>References</h2>
<p>[1] R. C. Eberhart and J. Kennedy.<br />
 A new optimizer using particle swarm theory.<br />
 In Proc. 6th International Symposium on Micro Machine and Human Science, pages 39–43, 1995.</p>
<p>[2] J. Kennedy and R. C. Eberhart.<br />
 Particle swarm optimization.<br />
 In Proc. IEEE International Conference on Neural Networks, volume 4, pages 1942–1948, 1995.</p>
<p>[3] B. K. Panigrahi, Y. Shi, and M.-H. Lim, editors.<br />
 Handbook of Swarm Intelligence — Concepts, Principles and Applications.<br />
 Springer, 2011. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
