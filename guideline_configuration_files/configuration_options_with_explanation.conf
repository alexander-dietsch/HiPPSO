# Configuration file for particle swarm optimization
# lines containing "#" are comments
# only a single value can be set in each line
# Particles are 0-indexed, the ids of the particles are in the range from 0 to <number of particles> - 1
# Dimensions are 0-indexed, the ids of the dimensions are in the range from 0 to <number of dimensions> - 1


# Set file prefixes of generated data:
#fileprefix <fileprefix>
# If none is specified then an automatic string is generated by
# specified values in this configuration file.
# Example:
#fileprefix Run00001

# Set whether the current date and time should be included in the
# filenames:
includeSystemTimeInFilename true
#includeSystemTimeInFilename < true | false >

# WARNING: There is no check whether the respective prefix is already
# in use. If a prefix is used repeatedly in the same folder, then the
# program may produce wrong / useless data and may also destroy data of 
# other executions of this program. Therefore it is highly recommended
# to set the "includeDateInFilename" value to true, because this
# automatically produces different prefixes for each execution, which
# have not started at the same second.

# Set parameters for velocity update in PSO.
# V= (chi)*V + c_1 * r_1 * (L - X) + c_2 * r_2 * (G - X)
# where V = velocity, c_1 = coefficient local attractor,
# r_1 and r2 random values in [0,1], L = local attractor
# X = position, c_2 = coefficient global attractor, G global attractor
parameterChi 0.72984
parameterCoefficientLocalAttractor 1.496172
parameterCoefficientGlobalAttractor 1.496172

# Set when the global attractor is updated.
updateGlobalAttractor eachParticle
#updateGlobalAttractor < eachIteration | eachParticle >
# The option eachIteration means that the global attractor is updated
# after each iteration. Particles with higher index do not recognize
# improvements of earlier particles in the same iteration.
# The option eachParticle means that the global attractor is updated
# immediately after each particle has found a new position.

# Set initial precision (in bits) of used dataType.
initialprecision 500
# Set precision (in bits) of used dataType.
precision 500

# Set when the precision is checked.
checkprecision allExceptStatistics
#checkprecision < all | allExceptStatistics | never >
#checkprecision all
# checks precision always.
#checkprecision allExceptStatistics
# checks precision always except on statistical calculations.
# Useful if runs should be reproducible not depending
# on whether statistics are done or not.
#checkprecision never
# never checks precision.

# Set the ratio how often the precision is checked expectedly
checkprecisionprobability 1.00
#checkprecisionprobability <ratio>
# A ratio of 0.0 means that the precision is never checked.
# A ratio of 1.0 means that the precision is always checked.
# A ratio of 0.5 means that for 50% of the calculations the precision is checked.

# Set the number of particles.
particles 8

# Set the number of dimensions.
dimensions 8

# Set the number of steps (iterations).
steps 1000

#Specify the random number generator (RNG) which should be used.
srand 1
#srand <random number generator description>
#<random number generator description> ::= <seed> | linearCongruenceRNG <seed> <lcrng>
#<lcrng>                               ::= standard <mpf generation 1> | mod2p63 <multiplier> <adder> <mpf generation 1> | specific <multiplier> <adder> <modulus> <mpf generation 2>
#<mpf generation 1>                    ::= fast | intense <used bits>
#<mpf generation 2>                    ::= fast | intense
# <seed> is the seed of the RNG. This number should be a non negative integer.
# RNGs have 3 methods for random number generation. (Generation of random long long values, double values and mpf_t values)
# A linear congruence RNG works in the following way:
# It contains a <multiplier> (a nonnegative integer less than 2^63) an adder (a nonnegative integer less than 2^63) and a <modulus> (a positive integer less or equal than 2^63).
# The next random long long value is calculated with the formula
#  (<adder> + <seed> * <multiplier>) mod <modulus>
#  where <seed> is either the specified <seed> if the method is called the first time or the previously generated random number.
# The next random double value is calculated by a random long long value divided by the <modulus>.
# If mpf generation is specified as fast then for mpf_t value generation a random double value is converted to a mpf_t value.
# If mpf generation is specified as intense then the result is sum_{i=1..t} (random long long value) / (<modulus>^i)
# where t is as large such that all bits of the random mpf_t are randomly generated.
# If additionally the <used bits> can be specified then only the highest <used bits> bits of the random long long value are used.
# This makes sense because if the modulus is a power of 2 then the lowest bits have very short periodicity.
# The formula then changes to sum_{i=1..t} (random integer value of the highest <used bits> bits) / ( 2^( i * <used bits> ) ).
# With subcommand specific all values can be specified. For example
#srand linearCongruenceRNG 1 specific 2 3 4 fast
#srand linearCongruenceRNG 1 specific 2 3 4 intense
# With subcommand mod2p63 the <modulus> is fixed to the value 2^63.
# This is much faster because modulo operations are mainly implicitly done by overflows of unsigned long long values.
# Examples:
#srand linearCongruenceRNG 1 mod2p63 2 3 fast
#srand linearCongruenceRNG 1 mod2p63 2 3 intense 30
# With subcommand standard also the <multiplier> and <adder> are fixed. (<multiplier> = 1571204578482947281, <adder> = 12345678901234567).
# Examples:
#srand linearCongruenceRNG 1 standard fast
#srand linearCongruenceRNG 1 standard intense 30
# The following four definitions produce the same random values:
#srand 42
#srand linearCongruenceRNG 42 standard fast
#srand linearCongruenceRNG 42 mod2p63 1571204578482947281 12345678901234567 fast
#srand linearCongruenceRNG 42 specific 1571204578482947281 12345678901234567 9223372036854775808 fast

# Set how velocity should be initialized.
initializeVelocity zero
#initializeVelocity < zero | halfDiff | random >
#initializeVelocity zero
# initializes all velocity entries to zero.
#initializeVelocity halfDiff
# samples a second position for each particle, subtracts the actual position and
# multiplies the result by 0.5.
#initializeVelocity random
# Velocities are initialized similar to the position.
# See command initializationinformation.

# Set how positions and velocities are initialized

#initializationinformation <position or velocity> <affected particles and dimensions> <initialization type>
# with
# <position or velocity>              ::= position | velocity
# <affected particles and dimensions> ::= <first particle id> <last particle id> <first dimension id> <last dimension id>
# <initialization type>               ::= bounds <lower bound> <upper bound> |
#                                         centerandrange <center coordinate> <range> |
#                                         randomcenterandrange <center coordinate lower bound> <center coordinate upper bound> <range> |
#                                         scale <scale> |
#                                         powerscale <power scale>

#Detailed information about the command "initializationinformation":

# <position or velocity> specifies whether the command influences the
#   initialization of the position or the velocity.
#   WARNING: The commands which influences the velocity initialization
#            are ignored if velocity initialization is not random.
#            For example if the command "initializeVelocity halfDiff"
#            or "initializeVelocity zero" is active then the command
#            "initializationinformation" with subcommand "velocity" has no effect.
# <affected particles and dimensions> specifies which particles and
#   which dimensions are affected. The specified indices should be integers.
#   The indices are treated zero indexed and inclusive specified index bounds.
# <initialization type>:
# bounds <lower bound> <upper bound>
#   specifies that the coordinates of all particles and dimensions in the specified
#   range are randomly initialized in the range from <lower bound> to <upper bound>.
#   <lower bound> and <upper bound> can be floating point values.
# centerandrange <center coordinate> <range>
#   specifies that the coordinates of all particles and dimensions in the specified
#   range are randomly initialized in the interval from
#   (<center coordinate> - <range>) to (<center coordinate> + <range>).
#   <center coordinate> and <range> can be floating point values.
# randomcenterandrange <lower bound> <upper_bound> <range>
#   specifies that the coordinates of all particles and dimensions in the specified
#   range are randomly initialized in the interval from (x - <range>) to
#   (x + <range>), where x is a random value in the interval <lower bound> to
#   <upper bound> and x is sampled for each dimension independently.
# scale <scale>
#   specifies that the length of the random interval of all particles and dimensions
#   in the specified range are scaled by a factor of <scale>.
#   The center of the interval stays constant.
#   <scale> can be a floating point value.
# powerscale <power scale>
#   specifies that the length of the random interval of all particles and dimensions
#   in the specified range are scaled by a factor of 2^(<power scale>).
#   The center of the interval stays constant.
#   <power scale> needs to be an integer (negative or positive).

# The subcommands "bounds", "centerandrange" and "randomcenterandrange" are
# procceded in the same order as they are inserted in the configuration file.
# Therefore such commands can overwrite previous commands of these three
# types if they have an effect on the same particles and dimensions.
# For example if subcommand "centerandrange" on particles 0 to 4 and
# dimensions 4 to 7 is stated and the subcommand "bounds" on particles 
# 3 to 5 and dimensions 2 to 5, then for the overlap (particles 2 to 4
# and dimensions 4 to 5) the later subcommand "bounds" is in effect. For
# the remaining particles and dimensions the subcommands "centerandrange"
# and "bounds" are in effect as specified.
# The remaining subcommands "scale" and "powerscale" can coexist. This means
# if two (or more) of those commands appear for the same particle and dimension
# then all of them will be executed.
# Furthermore the subcommands "scale" and "powerscale" are executed after
# all subcommands "bounds", "centerandrange" and "randomcenterandrange"
# are finished. Therefore a different ordering of the subcommands "scale" and
# "powerscale" has no effect.

# For all particles and dimensions where no range is specified the function bounds
# are used. For position sampling there is just random sampling inside the function bounds.
# For velocity sampling inside function bounds (not for initialization with command
# initializationinformation) additionally the center of the function bounds is subtracted
# to ensure that for each dimension positive and negative direction has equal probability.

# Set neighborhood topology.
neighborhood gBest
#neighborhood < gBest | wheel | lBest <2k> | ring | grid <r> <c> >
# The topology specifies which particles are known by other particles
# i.e., if particle i knows particle j then the best position found by
# particle j is considered for the choice of global attractor for particle i.

#neighborhood gBest
# topology gBest:
# All particles know each other.
# Single common global attractor for all particles.
#neighborhood wheel
# topology wheel:
# All particles know the first particle and the first particle knows all particles.
# The global attractor of the first particle is the best position of all particles.
# The global attractor of all other particles is the best position of itself and the best position of the first particle.
#neighborhood lBest <2k>
# topology lBest <2k>:
# Each particle knows the next and the previous <2k> / 2 particles.
# For example "neighborhood lBest 10" specifies that each particle knows the next and the previous 5 particles.
#neighborhood ring
# topology ring:
# Each particle knows the next and the previous particle.
# (equivalent to "lBest 2")
#neighborhood grid <r> <c>
# (for example: "neighborhood grid 4 9" if there are 36 particles)
# topology grid <r> <c>:
# The particles are assigned a position in a <r> x <c> grid.
# Each particle knows the four particles next to him:
# i.e. the particle above, below, left and right to him in a cyclical sense.
# [ <r>*<c> must be equal to the number of particles !! ]

function standard sphere
#function <function type>
# The type of function (<function type>) should be specified
# as described with the following grammar, which is specified
# in Backus-Naur Form:

# <function type>                 ::= <direct function type> | <modification> <function type> | <merge operator> <specific function type> | combine <operation> <function type> <function type>
# <direct function type>          ::= standard <standard function> | constant <constant value>
# <standard function>             ::= sphere | scaledsphere | scaledsphere2 <scale> | scaledsphererand <random number generator description> | scaledandhadamardrotatedshpere | scaledandhadamardrotatedshpere2 <scale> | 
#                                     monosphere | schwefel | schwefel2 | rosenbrock | movedrosenbrock | rastrigin | randomposdef <random number generator description> | diagonal <scale> |
#                                     norm1 | normoo | norm2 | norm4 | norm8 | norm2pk <int exponent> | norm1pl2pmk <int exponent> | sphereplus | inclinedplane | inclinedplaneasym |
#                                     twoCupsFunction | sortFunction | singleDifferentDirection <single dimension power> <remaining dimension power> <direction_mode> | testing
# <direction_mode>                ::= firstDimension | diagonalDirection | randomDirection <random number generator description>
# <modification>                  ::= sqrt | log2 | logE | abs | pow <exponent> | exp | sin | cos | tan | arcsin | arccos | arctan
# <specific function type>        ::= <direct specific function type> | <modification> <specific function type> | combine <operation> <specific function type> <specific function type>
# <direct specific function type> ::= identity | constant <constant value>
# <merge operator>                ::= merge <merge type>
# <merge type>                    ::= specific <object id> | increasingOrderNthObject <object id> | arithmeticAverage | geometricAverage | sum | product | maximum | minimum | functionEvaluation <function type>
# <constant value>                ::= E | Pi | plusInfinity | minusInfinity | <floating point number>
# <exponent>                      ::= <floating point number>
# <operation>                     ::= + | - | * | / | min | max
# <object id>                     ::= <integer>
# <scale>                         ::= <floating point number>
# <int exponent>                  ::= <positive integer>
# <single dimension power>        ::= <floating point number>
# <remaining dimension power>     ::= <floating point number>
# <random number generator description>  See section about random number generator ("srand")!

# <function type>:
#   A <function type> is some specification of an evaluation
#   which can be executed on a position vector and produces a single result value.
# <direct function type>:
#   <direct function type> describes a specific function directly.
# <standard function>:
#   This option offers the chance to use a variety of pre implemented functions:
# sphere is the well know sphere function sphere(x) = sum ((x_i)^2)
# scaledsphere is a scaled version of the sphere function
#   scaledsphere (x) = sum ((10^6)^(i/(D-1))(x_i^2))
# scaledsphere2 <scale> is the same but the user can specify the scale
#   scaledsphere2 <scale> (x) = sum ((<scale>)^(i/(D-1))(x_i^2))
# scaledsphererand <random number generator description> is a randomized version with randomly generated scales per dimension
#   scaledsphererand <random number generator description> (x) = sum (r_i(x_i^2)) where r_i are once random generated non negative integer numbers with given RNG.
# scaledandhadamardrotatedshpere: for D = 2^d scaledandhadamardrotatedshpere is a scaledsphere with hadamard rotated x
# scaledandhadamardrotatedshpere2 <scale> is analogously to scaledsphere2
# monosphere (x) = (x_0)^2
# schwefel (x) = sum_{i=0..D-1} ((sum_{j=0..i} x_j)^2)
# schwefel2 (x) = sum_{i=0..D-1} (-x_i * sin(sqrt(abs(x_i))))
# rosenbrock (x) = sum{i=0..D-2} (100 * (x_{i+1} - x_i * x_i)^2 + (1 - x_i)^2
# movedrosenbrock (x) =rosenbrock([(x_1)+1,(x_2)+1,....])
# rastrigin (x) = sum{i=0..D-1} (10 + x_i^2 - 10 * cos(2 * PI * x_i))
# randomposdef <random number generator description> (x) = Transpose(x) * A * x
#   with once random generated positive definite matrix A with given RNG
# diagonal <scale> (x) = (sphere (x)) + <scale> * (sum(x_i))^2
# norm1 (x) = sum abs(x_i)
# normoo is the infinity norm: normoo (x) = max abs(x_i)
# norm2 = sphere
# norm4 (x) = sum ((x_i)^4)
# norm8 (x) = sum ((x_i)^8)
# norm2pk <int exponent> == norm 2^<int exponent>
#   norm2pk <int exponent> (x) = sum ((x_i)^(2^<int exponent>))
# norm1pl2pmk <int exponent> == norm (1+2^(-<int exponent>))
#   norm1pl2pmk <int exponent> (x) = sum ((abs(x_i))^(1+2^(-<int exponent>)))
# sphereplus (x) = (sphere (x)) if every entry of x is non-negative, and INFINITY otherwise.
# inclinedplane (x) = -sum_{d=0..D-1} x_d
# inclinedplaneasym (x) = -sum_{d=0..D-1} (d+1)*x_d
# twoCupsFunction (x) = sum_{d=0..D-1} f(x_d)
#   with f(y) = (y+1)^2 if y <  0
#             = (y-1)^4 if y >= 0
# sortFunction (x) = sum_{0<=d_1<d_2<D}(x[d_1]>=x[d_2])
# singleDifferentDirection <single_dimension_power> <remaining_dimension_power> <direction_mode>
#   let "dir" be the specified direction specified by the <direction mode>
#   singleDifferentDirection (x){
#     proj := ((x.dir)/(dir.dir)) * dir  (this is the projection of the current position to dir)
#     orth := x - proj                   (this is the orthogonal part of the position)
#     return (proj.proj)^<single dimension power> + (orth.orth)^<remaining dimension power>
#   }
#   where (a.b) is the scalar product of the vectors a and b
# <direction mode>
# if <direction mode> = firstDimension then dir=(1,0,...,0)
# if <direction mode> = diagonalDirection then dir=(1,1,...,1)
# if <direction mode> = randomdirection <random number generator description> then dir=(y_0,...,y_(D-1))
#        where each y_i is an independent normal distributed random
#        variable with expectation 0 and variance 1 generated with the given RNG and its random double values.
#   examples:
#    function standard singleDifferentDirection 4 1 firstDimension
#    function standard singleDifferentDirection 1 4 diagonalDirection
#    function standard singleDifferentDirection 0.5 12.25 randomDirection 4242
# testing
#   This function is just for testing and debugging.
#   Behavior and shape is not defined and may change
#   during the process or after software updates.
# constant <constant value> represents a function, which always evaluates to the same
#   specified value. This specific function can be combined with other functions.
# The combine commands:
#   combine <operation> <function type> <function type>
#   combine <operation> <specific function type> <specific function type>
#   can be used to evaluate complex functions. You can use add (+), subtract (-),
#   multiply (*) and divide (/) as possible operations to combine various functions.
#   Each operation is executed element wise. The description suggests a prefix notation
#   for the evaluation which uniquely specifies the order of execution.
#   WARNING: Undefined values can not be compared. This happens for example with division by zero.
# <modification>:
#   A <modification> is applied to values delivered by the connected object element wise.
# sqrt is the square root.
#   WARNING: executions with negative values result in undefined values.
# log2 is the logarithm with base 2.
#   WARNING: executions with negative values result in undefined values.
# logE is the natural logarithm (logarithm with base E).
#   WARNING: executions with negative values result in undefined values.
# abs is the absolute value.
# pow <exponent> is the power of the value with the specified exponent.
#   WARNING: executions with negative values (can) result in undefined values.
# exp is the exponential function.
# sin is the sine function.
# cos is the cosine function.
# tan is the tangent function.
# arcsin arccos arctan are the respective arcus-functions (inverse trigonometric functions)
# <specific function type>:
#   This type represents a vector of values, which is calculated with the given position.
#   It needs to be merged in some way to receive an usable function, which
#   can then be evaluated.
# <direct specific function type>:
#   <direct specific function type> describes a specific <specific function type> directly.
# identity supplies position/input, which should be evaluated.
# constant <constant value> represents a function, which always evaluates to
#   the same specified value. The number of dimensions of the result will be equal to the
#   number of dimensions of the input.
# The combine commands:
#   combine <operation> <function type> <function type>
#   combine <operation> <specific function type> <specific function type>
#   can be used to evaluate complex functions. You can use add (+), subtract (-),
#   multiply (*) and divide (/) as possible operations to combine various functions.
#   Each operation is executed element wise. The description suggests a prefix notation
#   for the evaluation which uniquely specifies the order of execution.
# <merge operator>:
#   The merge operator merges the data vector received from some specific function
#   to a single numbers. Some kind of accumulation can be done.
# <merge type>:
#   The merge type specifies how values are combined.
# specific <object id> picks only the values at some specified id.
#   Example:
#     Let the data vector be {2,5,7} then the following results are achieved:
#     "merge specific 0" -> 2
#     "merge specific 1" -> 5
#     "merge specific 2" -> 7
# increasingOrderNthObject <object id> picks the value at the specified position
#   after the values, which should be merged, are sorted.
# arithmeticAverage calculates the arithmetic average of the values which should be merged.
# geometricAverage calculates the geometric average of the values which should be merged.
# sum caculates the sum of the values which should be merged.
# product calculates the product of the values which should be merged.
# maximum calculates the maximal value of the values which should be merged.
# minimum calculates the minimal value of the values which should be merged.
# functionEvaluation interprets the values which should be merged as input of the specified
#   function and evaluates this function. This might fail if the number of entries does not
#   match the specified number of dimensions, because then the input can possibly not be
#   interpreted as valid position.

# Examples for functions:
#  sphere function (two variants)
#function standard sphere
#function merge sum pow 2 identity
#  function <k>-Norm:
#function merge sum pow <k> abs identity
#function merge sum pow 17 abs identity
#  monosphere (two variants)
#function standard monosphere
#function pow 2 merge specific 0 identity
#  diagonal 1000 function (two variants)
#function standard diagonal 1000
#function combine + merge sum pow 2 identity combine * constant 1000 pow 2 merge sum identity
#  moved rosenbrock function such that origin is optimum (two variants)
#  WARNING: Second variant does not preserve standard function bounds of rosenbrock function.
#           Use functionbounds command to set them manually.
#function standard movedrosenbrock
#function merge functionEvaluation standard rosenbrock combine + identity constant 1

#functionbounds <first dimension id> <last dimension id> <lower bound> <upper bound>
# Sets the lower and upper bound of the bounding box for the function to the given values
# for all dimensions form <first dimension id> to <last dimension id>.
# Relevant for initialization of the particles (if "initializationinformation"
# with subcommands "bounds", "centerandrange" and "randomcenterandrange" is not used) and
# it is relevant for bound handling and for the option functionInfinityOutside.
# For standard function the usual function bounds are implemented, but for all other functions or
# functions consisting of more than just a standard function the function bounds are set to
# [-100.0, 100.0] in all dimensions. If any other function bound is intended, then it need to
# be specified!


# set position and velocity updater
positionAndVelocityUpdater default
#positionAndVelocityUpdater < default | orientationChange <v> | delta <delta> | delta <delta> <gamma> | dimensionindependent <reduction> <max_directions> | testing >

#positionAndVelocityUpdater default
# means just that the well known movement equations are used in their standard form.

#positionAndVelocityUpdater orientationChange 10
# positionAndVelocityUpdater orientationChange <v>
# means the following:
# Random values of the standard movement equations are calculated in an orthogonal transformed space
# let p[i] = log_2 (abs(v[i]) + abs(x[i] - l[i]) + abs(x[i] - g[i]))
# where x[i], v[i], l[i] and g[i] are the position, velocity, local attractor and
# global attractor of particle i at the current iteration.
# If in current orientation the minimal and maximal value of p[i] differ more than v
# then the lowest and largest directions are rotated with a hadamard transformation.
# Beside that change the default behaviour is used.

#positionAndVelocityUpdater delta 1e-5
# positionAndVelocityUpdater delta <delta>
# means that if for a particle and all dimensions (abs(x[i]-g[i]) + abs(v[i])) < (<delta>)
# then the velocity is initialized randomly in [-<delta>, <delta>] for all dimensions.
# Otherwise default behaviour is used.

#positionAndVelocityUpdater delta 5 0.9
# positionAndVelocityUpdater delta <delta> <gamma>
# means the same but with limit and scale <delta>*(<gamma>^k) where k is the number
# of times the random initialization of the velocity is applied already.
# If <gamma> == 1.0 then this updater performs equal to the updater with only one parameter.

#positionAndVelocityUpdater dimensionindependent 0.001 2
#positionAndVelocityUpdater dimensionindependent <reduction> <max_directions>
# means that for each update is performed in at most <max_directions> directions.
# Each update direction is calculated orthogonally to the previous directions and
# is performed in main movement direction plus some random direction scaled by <reduction>.
# The smaller the value of <reduction> is the greater is the portion of the
# main movement direction belonging to the first sampled direction.
# Formally:
# First the previous velocity is scaled by the specified swarm parameter
# main movement direction = 
# (difference vector of local and global attractor) if they are not equal
# (difference vector of position and any of the equal attractors) otherwise
# if this vector is a zero vector then position and attractors are equal and therefore
# there is no vector to local/global attractor, which can be scaled randomly.
# The directions are sampled iteratively:
# used_directions := {}
# for d from 1 to <max_directions> - 1 do
#   random_direction := uniformly at random choose a direction orthogonal to used_directions
#   remaining_main_direction := part of main movement direction which is orthogonal to used_directions
#   normalize both directions
#   next_direction = random_direction * <reduction> + remaining_main_direction
#   // The smaller the value of <reduction> is the more of the remaining_main_direction 
#   // will be covered by the next direction.
#   perform standard PSO velocity update with local/global attractor in this direction
#   add next_direction to used_directions
# end for
# calculate orthogonal part of difference vector to attractors
# perform standard PSO velocity update in this directions

#positionAndVelocityUpdater testing
# this positionAndVelocityUpdater is just for testing
# and debugging. Behavior is not defined and may change
# during the process or after software updates.

# set bound handling
boundhandling noBounds
#boundhandling < noBounds | absorption <adjust dimensions> | randomforth <adjust dimensions> | random < resetAll | resetViolated > | hyperbolic | nearest | reflect | torus >
# <adjust dimensions> ::= markAllOnChange | markAllOutsideBoundsWithoutChange | markAllOnBoundsAfterChange
#boundhandling noBounds
#  With bound handling noBounds it is allowed that the new position is outside of the function bounds.
#  No change of position or velocity happens in that case. In addition to that bound handling strategy
#  with command functionInfinityOutside it can be specified whether all values outside of the function
#  bounds are calculated with the specific function or are directly set to +infinity.
#boundhandling absorption <adjust dimensions>
#   With absorption the new position will be old position + velocity if this lies within the bounds
#   and old position + scale * velocity otherwise, where scale is the largest value in [0.0, 1.0] such that
#   the new position lies within or on the function bounds.
#   <adjust dimensions> specifies which dimensions are marked as to be adjusted with the velocity adjustment.
#     markAllOnChange specifies that all dimensions are marked if any scaling is necessary.
#     markAllOutsideBoundsWithoutChange specifies that all dimensions are marked where the new position would have been
#        outside of the bounds without scaling.
#     markAllOnBoundsAfterChange specifies that all dimensions are marked where the scaled new position lies on the boundary.
#boundhandling randomforth <adjust dimensions>
#   With absorption the new position will be old position + velocity if this lies within the bounds
#   and old position + randval * scale * velocity otherwise, where randval is a random value in the interval [0, 1]
#   (uniformly at random for each application) and scale is the largest value in [0.0, 1.0] such that
#   the new position lies within or on the function bounds.
#   <adjust dimensions> specifies which dimensions are marked as to be adjusted with the velocity adjustment.
#     Same as for absorption bound handling.
#boundhandling random < resetAll | resetViolated >
#   With random the position is resampled uniformly inside the function bounds.
#   With random resetAll all dimensions are resampled
#   With random resetViolated only for dimensions with violations resampling is applied.
#boundhandling hyperbolic
#   With hyperbolic the velocities are adjusted each time.
#   For each particle and for each dimension the following is applied:
#   If velocity is positive then it is multiplied by 1 / ( 1 + abs( velocity / ( function upper bound - position ) ) )
#   else it is multiplied by 1 / ( 1 + abs( velocity / ( position - function lower bound ) ) )
#   WARNING: Any specification of a velocity adjustment is ignored with hyperbolic, because it already adjusts velocity.
#boundhandling nearest
#   With nearest the position is adjusted to the nearest position inside or on the function bounds.
#boundhandling reflect
#   With reflect the movement is reflected at the function boundaries. (Also known as mirror)
#boundhandling torus
#   With torus the movement is wrapped around the function bounds.
#   For the movement equations the directions to the attractors are calculated either directly or through the function bounds
#   depending on which of the possible directions is shorter.
#   I. e. let X = 0.8 , L = 0.1 and G = 0.6 be position, local attractor and global attractor in a single dimension and
#   let 0 be the lower function bound and 1 be the upper function bound then the direction to the local attractor "(L-X)" is 0.3
#   and the direction to the global attractor is -0.2.
# The bound handling bounded mirror can not be stated directly because mirroring a function is not possible with functionality of bound handling.
# Instead it can be described by the boundhandling torus and manually mirroring the function.
# Mirroring the function can be easily achieved.
# Let <function description> be the <function type> which should be processed and let <lb> and <ub>
# be the lower and upper function bounds. Then you can use the following commands for mirroring:
#function merge functionEvaluation <function description> combine - constant <ub> abs identity
#functionbounds 0 (<number of dimensions> - 1) (<lb> - <ub>) (<ub> - <lb>)
# where expressions in round brackets '(' ')' need to be calculated by hand.
# With this commands the function is mirrored to the positive direction. For mirroring to the negative direction you can use
#function merge functionEvaluation <function description> combine + constant <lb> abs identity
#functionbounds 0 (<number of dimensions> - 1) (<lb> - <ub>) (<ub> - <lb>)

# The following command decides how the function value is set if the position is outside of the function bounds.
functionBehaviorOutsideOfBounds infinity
#functionBehaviorOutsideOfBounds < normal | infinity | periodic >
#functionBehaviorOutsideOfBounds normal
# tries to evaluate the function with specified evaluation even if the position is outside of the function bounds.
#functionBehaviorOutsideOfBounds infinity
# sets the value to +infinity if the position is outside of the function bounds.
#functionBehaviorOutsideOfBounds periodic
# moves the position with modulo operations inside the search space and then evaluates the function if the position is outside of the function bounds.
# I.e. Let LB UB and X be lower function bound, upper function bound and position in current dimension. Then the evaluated position is (X - floor((X - LB) / (UB - LB)) * (UB - LB))
# This is applied to all dimensions outside of the function bounds.

# set velocity adjustment
velocityAdjustment none
#velocityAdjustment < none | zero | mirror | deterministicBack <lambda> | randomBack | adjust >
# The respective velocity adjustment is applied after boundhandling
# and is applied to all dimensions which are marked by boundhandling as adjusted.
#velocityAdjustment none
# Velocity will not be adjusted.
#velocityAdjustment zero.
# Velocity of adjusted dimensions will be set to zero.
#velocityAdjustment mirror
# Velocity of adjusted dimensions will be multiplied by -1.
#velocityAdjustment deterministicBack <lambda>
# Velocity of adjusted dimensions will be multiplied by -<lambda>.
# <lambda> should be a floating point value. The value is most likely positive.
# A typical value for <lambda> is 0.5 .
#velocityAdjustment randomBack
# Same as deterministicBack but <lambda> is sampled independent and uniformly at random in [0,1].
#velocityAdjustment adjust
# The new velocity is adjusted to the difference of the new position, which is already modified by
# a bound handling mechanism, and the old position.

#showStatistics <start step> <end step> <steps between shows>
# Set at which iterations the statistics should be stored.
# If more such times are specified all will be regarded.
# The following two will show statistics each 100 steps 
# (for a very long period) AND each step between 10000 and 10100
#showStatistics 100 1222111222 100
#showStatistics 10000 10100 1

#showStatistic <statistic type>
#showNamedStatistic <statistic name> <statistic type>
# The type of statistic (<statistic type>) should be specified
# as described with the following grammar, which is specified
# in Backus-Naur Form:

# <statistic type>                 ::= <direct statistic type> | <modification> <statistic type> | <merge operator> <specific statistic type> | combine <operation> <statistic type> <statistic type>
# <direct statistic type>          ::= globalBestPosition | globalBestPositionDistanceTo1DOptimum | globalBestPositionFunctionEvaluation | localAttractorUpdates | globalAttractorUpdates | precision | constant <dimensions> <constant value>
# <modification>                   ::= sqrt | log2 | log2dbl | logE | abs | pow <exponent> | exp | sin | cos | tan | arcsin | arccos | arctan
# <specific statistic type>        ::= <direct specific statistic type> | <modification> <specific statistic type> | combine <operation> <specific statistic type> <specific statistic type>
# <merge operator>                 ::= merge particle <merge type> | merge dimension <merge type>
# <merge type>                     ::= specific <object id> | increasingOrderNthObject <object id> | arithmeticAverage | geometricAverage | sum | product | maximum | minimum | functionEvaluation <function type> | objectiveFunctionEvaluation
# <direct specific statistic type> ::= position | velocity | localAttractor | globalAttractor | functionDifference | absVelocityPlusDistToGlobalAttractor <scale> | sqrtAbsVelocityPlusSqrtDistToGlobalAttractor <scale> | constant <constant value>
# <constant value>                 ::= E | Pi | plusInfinity | minusInfinity | <floating point number>
# <dimensions>                     ::= <integer>
# <exponent>                       ::= <floating point number>
# <operation>                      ::= + | - | * | / | min | max
# <object id>                      ::= <integer>
# <scale>                          ::= <floating point number>

# <statistic name>:
#   You can specify the name of the statistic, which specifies the final
#   part of the respective filename. Please do not use any whitespace characters.
#   Furthermore it is only guaranteed that the letters A-Z, a-z and 0-9 will work,
#   but you can use other characters on your own risk.

# <statistic type>:
#   A <statistic type> is some specification of an evaluation
#   which can be executed at the specified iterations
#   (specified by command showStatisticsIterations).
#   In general it produces at each evaluation a list of numbers.
# <direct statistic type>:
#   <direct statistic type> describes a specific statistic directly.
# globalBestPosition represents the best position found so far by the swarm.
# globalBestPositionDistanceTo1DOptimum represents the distance of the global best position
#   to the nearest local optimum if only a single dimension is variable.
# globalBestPositionFunctionEvaluation represents the function value of the specified
#   function where the input position is the best position found so far.
# localAttractorUpdates counts for each particle the number of changes of its local
#   attractor since the beginning.
# globalAttractorUpdates counts for each particle the number of changes of a global
#   attractor caused by that particle since the beginning.
# precision represents the current precision in bits, which is used for all calculations.
# constant <dimensions> <constant value> represents a statistic, which always evaluates to
#   the same specified value. The number of dimensions needs to be specified, because
#   the generated vector needs to have the correct number of entries if it should be combined
#   with other statistics.
# The combine commands:
#   combine <operation> <statistic type> <statistic type>
#   combine <operation> <specific statistic type> <specific statistic type>
#   can be used to evaluate complex statistics. You can use add (+), subtract (-),
#   multiply (*) and divide (/) as possible operations to combine various statistics.
#   Each operation is executed element wise. The description suggests a prefix notation
#   for the evaluation which uniquely specifies the order of execution.
# <modification>:
#   A <modification> is applied to values delivered by the connected object element wise.
# sqrt is the square root.
#   WARNING: executions with negative values result in undefined values.
# log2 is the logarithm with base 2.
#   WARNING: executions with negative values result in undefined values.
# logE is the natural logarithm (logarithm with base E).
#   WARNING: executions with negative values result in undefined values.
# log2dbl is the logarithm with base 2 calculated only with double precision.
#   WARNING: executions with negative values result in undefined values.
# abs is the absolute value.
# pow <exponent> is the power of the value with the specified exponent.
#   WARNING: executions with negative values (can) result in undefined values.
# exp is the exponential function.
# sin is the sine function.
# cos is the cosine function.
# tan is the tangent function.
# arcsin arccos arctan are the respective arcus-functions (inverse trigonometric functions)
# <specific statistic type>:
#   This statistic can be evaluated for each particle and for each dimension.
#   It needs to be merged in some way to receive a list of numbers, which
#   can then be displayed in a data file.
# The combine commands:
#   combine <operation> <statistic type> <statistic type>
#   combine <operation> <specific statistic type> <specific statistic type>
#   can be used to evaluate complex statistics. You can use add (+), subtract (-),
#   multiply (*) and divide (/) as possible operations to combine various statistics.
#   Each operation is executed element wise. The description suggests a prefix notation
#   for the evaluation which uniquely specifies the order of execution.
# <merge operator>:
#   The merge operator merges the data received for each particle and dimension
#   to some list of numbers. Some kind of accumulation can be done over particles
#   or over dimensions. Other accumulations are also possible.
# merge particle <merge type> merges the data over the particles and produces one
#   value for each dimension. (See examples below for clarification)
# merge dimension <merge type> merges the data over the dimensions and produces one
#   value for each particle. (See examples below for clarification)
# <merge type>:
#   The merge type specifies how values are combined.
# specific <object id> picks only the values of the specified object.
#   Example:
#     Let then number of particles be 2 and the number of dimensions be 3.
#     Let the position of particle 0 be     pos(0)={1,2,3}
#     and let the position of particle 1 be pos(1)={5,6,7}
#     then the result are achieved:
#     "merge particle specific 0 position" -> {1,2,3}
#     "merge particle specific 1 position" -> {1,2,3}
#     "merge dimension specific 0 position" -> {1,5}
#     "merge dimension specific 1 position" -> {2,6}
#     "merge dimension specific 2 position" -> {3,7}
# increasingOrderNthObject <object id> picks the value at the specified position
#   after the values, which should be merged, are sorted.
#   Example:
#     Let then number of particles be 2 and the number of dimensions be 3.
#     Let the position of particle 0 be     pos(0)={7,2,9}
#     and let the position of particle 1 be pos(1)={6,8,1}
#     then the result are achieved:
#     "merge particle increasingOrderNthObject 0 position" -> {6,2,1}
#     "merge particle increasingOrderNthObject 1 position" -> {7,8,9}
#     "merge dimension increasingOrderNthObject 0 position" -> {2,1}
#     "merge dimension increasingOrderNthObject 1 position" -> {7,6}
#     "merge dimension increasingOrderNthObject 2 position" -> {9,8}
# arithmeticAverage calculates the arithmetic average of the values which should be merged.
#   Example:
#     Let then number of particles be 2 and the number of dimensions be 3.
#     Let the position of particle 0 be     pos(0)={2,4,3}
#     and let the position of particle 1 be pos(1)={6,8,1}
#     then the result are achieved:
#     "merge particle arithmeticAverage position" -> {4,6,2}
#     "merge dimension arithmeticAverage position" -> {3,5}
# geometricAverage calculates the geometric average of the values which should be merged.
#   Example:
#     Let then number of particles be 2 and the number of dimensions be 3.
#     Let the position of particle 0 be     pos(0)={64,1,729}
#     and let the position of particle 1 be pos(1)={256,4,2916}
#     then the result are achieved:
#     "merge particle geometricAverage position" -> {128,2,1458}
#     "merge dimension geometricAverage position" -> {36,144}
# sum caculates the sum of the values which should be merged.
#   Example:
#     Let then number of particles be 2 and the number of dimensions be 3.
#     Let the position of particle 0 be     pos(0)={2,4,3}
#     and let the position of particle 1 be pos(1)={6,8,1}
#     then the result are achieved:
#     "merge particle arithmeticAverage position" -> {8,12,4}
#     "merge dimension arithmeticAverage position" -> {9,15}
# product calculates the product of the values which should be merged.
# maximum calculates the maximal value of the values which should be merged.
# minimum calculates the minimal value of the values which should be merged.
# functionEvaluation interprets the values which should be merged as input of the specified
#   function and evaluates this function. This might fail if the number of entries does not
#   match the specified number of dimensions, because then the input can possibly not be
#   interpreted as valid position.
#   <function type> is specified in the section describing functions.
# objectiveFunctionEvaluation interprets the values which should be merged as input of the specified
#   objective function and evaluates this function. This might fail if the number of entries does not
#   match the specified number of dimensions, because then the input can possibly not be
#   interpreted as valid position.
#   The objective function is specified by the keyword function.
# <direct specific statistic type>:
#   <direct specific statistic type> describes a specific <specific statistic type> directly.
# position represents the positions for each particle.
# velocity represents the velocities for each particle.
# localAttractor represents the local attractor for each particle.
# globalAttractor represents the global attractor for each particle.
# functionDifference means abs(f(x)-f(x')) 
#   where x = position
#   x'[dim] = x[dim] + v[dim] for the measured dimension and
#   x'[dim] = x[dim] for all other dimensions
#   where v = velocity.
# absVelocityPlusDistToGlobalAttractor <scale> means
#   <scale>*abs(v[dim]) + abs(x[dim]-g[dim])
#   where x = position, v = velocity, g = global attractor
#   and dim the measured dimension.
# sqrtAbsVelocityPlusSqrtDistToGlobalAttractor <scale> means
#   <scale>*sqrt(abs(v[dim]) ) + sqrt( abs( x[dim] - g[dim] ) 
#   where x = position, v = velocity, g = global attractor
#   and dim the measured dimension.
# constant <constant value> represents a statistic, which always evaluates to the same
#   specified value. This specific statistic can be combined with other specific statistics.

# <floating point number> represents a floating point value, which is internally
#   stored in a c++ double data type.
# <integer> is internally stored in a c++ int data type.

# examples:
#showStatistic log2dbl merge particle maximum abs position
# This command shows for each dimension the maximal absolute value,
# which any of the particles have in logarithmic scale. This might be helpful
# if the swarm should converge to origin.
#showStatistic globalBestPosition
# This displays just the position of the best position found so far.
#showStatistic log2dbl merge particle arithmeticAverage abs velocity
# This displays the arithmetic averages of the particles absolute velocities in logarithmic scale
#showNamedStatistic myStatistic log2dbl sqrt abs sqrt pow 2 globalBestPosition
# If automatic filename becomes confusing then another filename can be specified.

# examples of former statistics:
# position:
#showStatistic log2dbl abs globalBestPosition
# velocity:
#showStatistic log2dbl merge particle maximum abs velocity
# diffToOpt:
#showStatistic log2dbl globalBestPositionDistanceTo1DOptimum
# examples of former potentials:
#showStatistic log2dbl merge particle maximum functionDifference
#showStatistic log2dbl merge particle maximum absVelocityPlusDistToGlobalAttractor 1.0
#showStatistic log2dbl sqrt merge particle sum absVelocityPlusDistToGlobalAttractor 1.0
#showStatistic log2dbl merge particle sum sqrtAbsVelocityPlusSqrtDistToGlobalAttractor 1.0
# alternative specification of the previous statistic:
#showStatistic log2dbl merge particle sum combine + sqrt abs velocity sqrt abs combine - position globalAttractor

# Set the precision (in digits) of numbers in output.
# (in general for all floating point numbers in statistical files)
# If the output precision is set to -1 then the full precision of the
# mpf_t floating point objects are displayed.
outputPrecision 10
#outputPrecision < <output precision in digits> | -1 >

#runcheck guideliine_configuration_files/runcheck.conf
#runcheck <runcheck configuration file>
# Set the file name for configuration file which specifies when / whether the program is allowed to run.
# The program parses this file repeatedly. Therefore changes are recognized on runtime.
# If the program recognizes that it is not allowed to run then it stores its current data and terminates normally.
# This can be used to terminate current PSO runs.
# See sample file runcheck.conf for available possibilities.
# This is optional.

# set special time steps, where backups are preserved
#preservebackup <timestep>
# For example uncomment the following line to receive the backup after initialization:
#preservebackup 0

# For debugging and observation of the swarm the following can be used:
#debugswarm
# This command activates the <debugswarm>-mode (generation of pictures
# which visualize the current state of the swarm and further output on terminal).
# WARNING 1: "gnuplot" has to be installed!!
# WARNING 2: It might be possible that you can not easily kill the PSO_program task with Ctrl+C in the terminal.
#            You need to kill the process either by typing "killall PSO_program" in another terminal
#            (this variant kills ALL(!!) instances of PSO_program)
#            or you can use the programs "top" or "htop" to kill the respective process.
# WARNING 3: It might be possible that this option causes large memory usage on hard disk.
# The program generates a folder according to the current file prefix.
# Execute the small script in this folder to generate the image files for each visualized step.
# The prefix of the files are the referencing steps.

#debugswarmShowGlobalAttractorTrajectory <number of footprints>
# This command specifies how many of the recent global attractors
# will be visualized in the generated images.
debugswarmShowGlobalAttractorTrajectory 100

#debugswarmImageGenerationFrequency <show_each_n-th_step>
# This command specifies how often the image will be regenerated.
# If the specified value is zero then no images will be generated.
debugswarmImageGenerationFrequency 10

#debugswarmShowGlobalAttractor < true | false >
# This command specifies whether the value and position of the current
# global attractor should be displayed on the terminal at each iteration.
debugswarmShowGlobalAttractor true

# The following command specifies (approximately) the resolution of the generated images.
#debugswarmXresolution <width of generated image in pixels>
debugswarmXresolution 2560
#debugswarmYresolution <height of generated image in pixels>
debugswarmYresolution 1440

#debugswarmGnuplotTerminal <terminal>
# This command specifies which terminal should be used in gnuplot.
# The available terminals depend on your system.
debugswarmGnuplotTerminal svg

#debugswarmOutput <image extentsion>
# This command specifies the extension of the generated image file.
# The extension should match to the chosen gnuplot terminal.
debugswarmOutput svg
