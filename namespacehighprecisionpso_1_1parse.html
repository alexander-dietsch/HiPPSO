<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>High Precision PSO: highprecisionpso::parse Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">High Precision PSO </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehighprecisionpso.html">highprecisionpso</a></li><li class="navelem"><a class="el" href="namespacehighprecisionpso_1_1parse.html">parse</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">highprecisionpso::parse Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains a large set of functions for parsing the configuration file.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1d57511bc5cb2ab1d88862679aba21ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a1d57511bc5cb2ab1d88862679aba21ab">ParseCombineFunction</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a1d57511bc5cb2ab1d88862679aba21ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a combined function starting at the given index.  <a href="#a1d57511bc5cb2ab1d88862679aba21ab">More...</a><br /></td></tr>
<tr class="separator:a1d57511bc5cb2ab1d88862679aba21ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc0dbbbc6c40f55089eff79e2ec004b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1SpecificFunction.html">SpecificFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a8dc0dbbbc6c40f55089eff79e2ec004b">ParseCombineSpecificFunction</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a8dc0dbbbc6c40f55089eff79e2ec004b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a combined specific function starting at the given index.  <a href="#a8dc0dbbbc6c40f55089eff79e2ec004b">More...</a><br /></td></tr>
<tr class="separator:a8dc0dbbbc6c40f55089eff79e2ec004b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eff6b46eb0f12d33ec7fe3a700828f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1SpecificStatisticalEvaluation.html">SpecificStatisticalEvaluation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a4eff6b46eb0f12d33ec7fe3a700828f7">ParseCombineSpecificStatistic</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a4eff6b46eb0f12d33ec7fe3a700828f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a combined specific statistical evaluation starting at the given index.  <a href="#a4eff6b46eb0f12d33ec7fe3a700828f7">More...</a><br /></td></tr>
<tr class="separator:a4eff6b46eb0f12d33ec7fe3a700828f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5675e0a8f8de9618eb43f0f94937eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Statistic.html">Statistic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#ab5675e0a8f8de9618eb43f0f94937eb8">ParseCombineStatistic</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:ab5675e0a8f8de9618eb43f0f94937eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a combined statistic starting at the given index.  <a href="#ab5675e0a8f8de9618eb43f0f94937eb8">More...</a><br /></td></tr>
<tr class="separator:ab5675e0a8f8de9618eb43f0f94937eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326060d402a7d760d4a68fa13a714fce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1ConstantEvaluation.html">ConstantEvaluation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a326060d402a7d760d4a68fa13a714fce">ParseConstantEvaluation</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a326060d402a7d760d4a68fa13a714fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a constant evaluation starting at the given index.  <a href="#a326060d402a7d760d4a68fa13a714fce">More...</a><br /></td></tr>
<tr class="separator:a326060d402a7d760d4a68fa13a714fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca1574c91c968ed9d3243c0503cbd53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a9ca1574c91c968ed9d3243c0503cbd53">ParseFunction</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a9ca1574c91c968ed9d3243c0503cbd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a function starting at the given index.  <a href="#a9ca1574c91c968ed9d3243c0503cbd53">More...</a><br /></td></tr>
<tr class="separator:a9ca1574c91c968ed9d3243c0503cbd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea87a5cee057e16968d96961b38e4a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#aea87a5cee057e16968d96961b38e4a6a">ParseFunctionReduceOperator</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:aea87a5cee057e16968d96961b38e4a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a function reduce operator starting at the given index.  <a href="#aea87a5cee057e16968d96961b38e4a6a">More...</a><br /></td></tr>
<tr class="separator:aea87a5cee057e16968d96961b38e4a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acd0a86f5769edb3826a0761f137ca5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a2acd0a86f5769edb3826a0761f137ca5">ParseOperation</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a2acd0a86f5769edb3826a0761f137ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for an operation starting at the given index.  <a href="#a2acd0a86f5769edb3826a0761f137ca5">More...</a><br /></td></tr>
<tr class="separator:a2acd0a86f5769edb3826a0761f137ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907233efffd069ba183204bc6a07c4ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1PairReduceOperation.html">PairReduceOperation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a907233efffd069ba183204bc6a07c4ee">ParsePairCombinationOperation</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a907233efffd069ba183204bc6a07c4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a pair combination operation starting at the given index.  <a href="#a907233efffd069ba183204bc6a07c4ee">More...</a><br /></td></tr>
<tr class="separator:a907233efffd069ba183204bc6a07c4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5302ea1caa852a3ee34483ea6e6a0724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Statistic.html">Statistic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a5302ea1caa852a3ee34483ea6e6a0724">ParseReduceOperator</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a5302ea1caa852a3ee34483ea6e6a0724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a reduce operator starting at the given index.  <a href="#a5302ea1caa852a3ee34483ea6e6a0724">More...</a><br /></td></tr>
<tr class="separator:a5302ea1caa852a3ee34483ea6e6a0724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c556a005a481022a8a7314f22902f24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1SpecificFunction.html">SpecificFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a1c556a005a481022a8a7314f22902f24">ParseSpecificFunction</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a1c556a005a481022a8a7314f22902f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a specific function starting at the given index.  <a href="#a1c556a005a481022a8a7314f22902f24">More...</a><br /></td></tr>
<tr class="separator:a1c556a005a481022a8a7314f22902f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade45f4f754ad70161f9c9610966cbbe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1SpecificStatisticalEvaluation.html">SpecificStatisticalEvaluation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#ade45f4f754ad70161f9c9610966cbbe3">ParseSpecificStatistic</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:ade45f4f754ad70161f9c9610966cbbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a specific statistical evaluation starting at the given index.  <a href="#ade45f4f754ad70161f9c9610966cbbe3">More...</a><br /></td></tr>
<tr class="separator:ade45f4f754ad70161f9c9610966cbbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295f16685a3805120cb13df23a427d20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a295f16685a3805120cb13df23a427d20">ParseStandardFunction</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a295f16685a3805120cb13df23a427d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a standard function starting at the given index.  <a href="#a295f16685a3805120cb13df23a427d20">More...</a><br /></td></tr>
<tr class="separator:a295f16685a3805120cb13df23a427d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa64a1889b71e22fb2c60c166ca6fd5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Statistic.html">Statistic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#afa64a1889b71e22fb2c60c166ca6fd5a">ParseStatistic</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:afa64a1889b71e22fb2c60c166ca6fd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a statistic starting at the given index.  <a href="#afa64a1889b71e22fb2c60c166ca6fd5a">More...</a><br /></td></tr>
<tr class="separator:afa64a1889b71e22fb2c60c166ca6fd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2410c7a32cab00ae3dd2b4aa5a4b47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1VectorReduceOperation.html">VectorReduceOperation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a5a2410c7a32cab00ae3dd2b4aa5a4b47">ParseVectorReduceOperation</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a5a2410c7a32cab00ae3dd2b4aa5a4b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a vector reduce operation starting at the given index.  <a href="#a5a2410c7a32cab00ae3dd2b4aa5a4b47">More...</a><br /></td></tr>
<tr class="separator:a5a2410c7a32cab00ae3dd2b4aa5a4b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9296e54f091bcfb86854d59834a29acf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a9296e54f091bcfb86854d59834a29acf">SignalInvalidCommand</a> (const std::vector&lt; std::string &gt; &amp;parameters)</td></tr>
<tr class="memdesc:a9296e54f091bcfb86854d59834a29acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the supplied parameters to stderr and let the program terminate with exit code 1.  <a href="#a9296e54f091bcfb86854d59834a29acf">More...</a><br /></td></tr>
<tr class="separator:a9296e54f091bcfb86854d59834a29acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains a large set of functions for parsing the configuration file. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1d57511bc5cb2ab1d88862679aba21ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a>* highprecisionpso::parse::ParseCombineFunction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a combined function starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a combined function. If nothing can be parsed as a combined function then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a combined <a class="el" href="classhighprecisionpso_1_1Function.html" title="This class is an abstract class. It supplies the interface for objective functions. ">Function</a> can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed combined <a class="el" href="classhighprecisionpso_1_1Function.html" title="This class is an abstract class. It supplies the interface for objective functions. ">Function</a> if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dc0dbbbc6c40f55089eff79e2ec004b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1SpecificFunction.html">SpecificFunction</a>* highprecisionpso::parse::ParseCombineSpecificFunction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a combined specific function starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a combined specific function. If nothing can be parsed as a combined specific function then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a combined specific function can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed combined specific function if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4eff6b46eb0f12d33ec7fe3a700828f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1SpecificStatisticalEvaluation.html">SpecificStatisticalEvaluation</a>* highprecisionpso::parse::ParseCombineSpecificStatistic </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a combined specific statistical evaluation starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a combined specific statistical evaluation. If nothing can be parsed as a combined specific statistical evaluation then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a combined specific statistical evaluation can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed combined specific statistical evaluation if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5675e0a8f8de9618eb43f0f94937eb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Statistic.html">Statistic</a>* highprecisionpso::parse::ParseCombineStatistic </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a combined statistic starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a combined statistic. If nothing can be parsed as a combined statistic then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a combined statistic can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed combined statistic if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a326060d402a7d760d4a68fa13a714fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1ConstantEvaluation.html">ConstantEvaluation</a>* highprecisionpso::parse::ParseConstantEvaluation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a constant evaluation starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a constant evaluation. If nothing can be parsed as a constant evaluation then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a constant evaluation can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed constant evaluation if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ca1574c91c968ed9d3243c0503cbd53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a>* highprecisionpso::parse::ParseFunction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a function starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a function. If nothing can be parsed as a function then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a function can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed function if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aea87a5cee057e16968d96961b38e4a6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a>* highprecisionpso::parse::ParseFunctionReduceOperator </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a function reduce operator starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a function reduce operator. If nothing can be parsed as a function reduce operator then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a function reduce operator can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed function reduce operator if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2acd0a86f5769edb3826a0761f137ca5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Operation.html">Operation</a>* highprecisionpso::parse::ParseOperation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for an operation starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of an operation. If nothing can be parsed as an operation then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If an operation can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed operation if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a907233efffd069ba183204bc6a07c4ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1PairReduceOperation.html">PairReduceOperation</a>* highprecisionpso::parse::ParsePairCombinationOperation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a pair combination operation starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a pair combination operation. If nothing can be parsed as a pair combination operation then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a pair combination operation can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed pair combination operation if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5302ea1caa852a3ee34483ea6e6a0724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Statistic.html">Statistic</a>* highprecisionpso::parse::ParseReduceOperator </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a reduce operator starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a reduce operator. If nothing can be parsed as a reduce operator then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a reduce operator can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed reduce operator if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c556a005a481022a8a7314f22902f24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1SpecificFunction.html">SpecificFunction</a>* highprecisionpso::parse::ParseSpecificFunction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a specific function starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a specific function. If nothing can be parsed as a specific function then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a specific function can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed specific function if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ade45f4f754ad70161f9c9610966cbbe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1SpecificStatisticalEvaluation.html">SpecificStatisticalEvaluation</a>* highprecisionpso::parse::ParseSpecificStatistic </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a specific statistical evaluation starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a specific statistical evaluation. If nothing can be parsed as a specific statistical evaluation then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a specific statistical evaluation can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed specific statistical evaluation if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a295f16685a3805120cb13df23a427d20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a>* highprecisionpso::parse::ParseStandardFunction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a standard function starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a standard function. If nothing can be parsed as a standard function then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a standard function can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed standard function if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afa64a1889b71e22fb2c60c166ca6fd5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Statistic.html">Statistic</a>* highprecisionpso::parse::ParseStatistic </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a statistic starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a statistic. If nothing can be parsed as a statistic then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a statistic can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed statistic if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a2410c7a32cab00ae3dd2b4aa5a4b47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1VectorReduceOperation.html">VectorReduceOperation</a>* highprecisionpso::parse::ParseVectorReduceOperation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a vector reduce operation starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a vector reduce operation. If nothing can be parsed as a vector reduce operation then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a vector reduce operation can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed vector reduce operation if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9296e54f091bcfb86854d59834a29acf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void highprecisionpso::parse::SignalInvalidCommand </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the supplied parameters to stderr and let the program terminate with exit code 1. </p>
<p>This function is called if a command in the configuration file can not be parsed. The supplied command will be printed to stderr with an error message. Finally the function let the program terminate with exit code 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The command of the configuration file which can not be parsed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
