<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>High Precision PSO: highprecisionpso::parse Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">High Precision PSO
   </div>
   <div id="projectbrief">High Precision Particle Swarm Optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehighprecisionpso.html">highprecisionpso</a></li><li class="navelem"><a class="el" href="namespacehighprecisionpso_1_1parse.html">parse</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">highprecisionpso::parse Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains a large set of functions for parsing the configuration file.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1d57511bc5cb2ab1d88862679aba21ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a1d57511bc5cb2ab1d88862679aba21ab">ParseCombineFunction</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a1d57511bc5cb2ab1d88862679aba21ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a combined function starting at the given index.  <a href="#a1d57511bc5cb2ab1d88862679aba21ab">More...</a><br /></td></tr>
<tr class="separator:a1d57511bc5cb2ab1d88862679aba21ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc0dbbbc6c40f55089eff79e2ec004b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1SpecificFunction.html">SpecificFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a8dc0dbbbc6c40f55089eff79e2ec004b">ParseCombineSpecificFunction</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a8dc0dbbbc6c40f55089eff79e2ec004b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a combined specific function starting at the given index.  <a href="#a8dc0dbbbc6c40f55089eff79e2ec004b">More...</a><br /></td></tr>
<tr class="separator:a8dc0dbbbc6c40f55089eff79e2ec004b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eff6b46eb0f12d33ec7fe3a700828f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1SpecificStatisticalEvaluation.html">SpecificStatisticalEvaluation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a4eff6b46eb0f12d33ec7fe3a700828f7">ParseCombineSpecificStatistic</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a4eff6b46eb0f12d33ec7fe3a700828f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a combined specific statistical evaluation starting at the given index.  <a href="#a4eff6b46eb0f12d33ec7fe3a700828f7">More...</a><br /></td></tr>
<tr class="separator:a4eff6b46eb0f12d33ec7fe3a700828f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5675e0a8f8de9618eb43f0f94937eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Statistic.html">Statistic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#ab5675e0a8f8de9618eb43f0f94937eb8">ParseCombineStatistic</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:ab5675e0a8f8de9618eb43f0f94937eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a combined statistic starting at the given index.  <a href="#ab5675e0a8f8de9618eb43f0f94937eb8">More...</a><br /></td></tr>
<tr class="separator:ab5675e0a8f8de9618eb43f0f94937eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326060d402a7d760d4a68fa13a714fce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1ConstantEvaluation.html">ConstantEvaluation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a326060d402a7d760d4a68fa13a714fce">ParseConstantEvaluation</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a326060d402a7d760d4a68fa13a714fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a constant evaluation starting at the given index.  <a href="#a326060d402a7d760d4a68fa13a714fce">More...</a><br /></td></tr>
<tr class="separator:a326060d402a7d760d4a68fa13a714fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca1574c91c968ed9d3243c0503cbd53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a9ca1574c91c968ed9d3243c0503cbd53">ParseFunction</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a9ca1574c91c968ed9d3243c0503cbd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a function starting at the given index.  <a href="#a9ca1574c91c968ed9d3243c0503cbd53">More...</a><br /></td></tr>
<tr class="separator:a9ca1574c91c968ed9d3243c0503cbd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a86cb4a3bba8d6dfd4eac01e7c76e7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a6a86cb4a3bba8d6dfd4eac01e7c76e7e">ParseFunctionMergeOperator</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a6a86cb4a3bba8d6dfd4eac01e7c76e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a function merge operator starting at the given index.  <a href="#a6a86cb4a3bba8d6dfd4eac01e7c76e7e">More...</a><br /></td></tr>
<tr class="separator:a6a86cb4a3bba8d6dfd4eac01e7c76e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab564d913e770b264adf000799e7655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Statistic.html">Statistic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#adab564d913e770b264adf000799e7655">ParseMergeOperator</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:adab564d913e770b264adf000799e7655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a merge operator starting at the given index.  <a href="#adab564d913e770b264adf000799e7655">More...</a><br /></td></tr>
<tr class="separator:adab564d913e770b264adf000799e7655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb273e1450786a73b0f106367f702ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Modification.html">Modification</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a8bb273e1450786a73b0f106367f702ff">ParseModification</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a8bb273e1450786a73b0f106367f702ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a modification starting at the given index.  <a href="#a8bb273e1450786a73b0f106367f702ff">More...</a><br /></td></tr>
<tr class="separator:a8bb273e1450786a73b0f106367f702ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32c6d497bda5c62401e1a9fa20b851b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1PairCombinationOperation.html">PairCombinationOperation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#ab32c6d497bda5c62401e1a9fa20b851b">ParsePairCombinationOperation</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:ab32c6d497bda5c62401e1a9fa20b851b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a pair combination operation starting at the given index.  <a href="#ab32c6d497bda5c62401e1a9fa20b851b">More...</a><br /></td></tr>
<tr class="separator:ab32c6d497bda5c62401e1a9fa20b851b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3423090789ee75111b9e3bd21dd6b78b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1RandomNumberGenerator.html">RandomNumberGenerator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a3423090789ee75111b9e3bd21dd6b78b">ParseRandomNumberGenerator</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a3423090789ee75111b9e3bd21dd6b78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a random number generator starting at the given index.  <a href="#a3423090789ee75111b9e3bd21dd6b78b">More...</a><br /></td></tr>
<tr class="separator:a3423090789ee75111b9e3bd21dd6b78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c556a005a481022a8a7314f22902f24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1SpecificFunction.html">SpecificFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a1c556a005a481022a8a7314f22902f24">ParseSpecificFunction</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a1c556a005a481022a8a7314f22902f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a specific function starting at the given index.  <a href="#a1c556a005a481022a8a7314f22902f24">More...</a><br /></td></tr>
<tr class="separator:a1c556a005a481022a8a7314f22902f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade45f4f754ad70161f9c9610966cbbe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1SpecificStatisticalEvaluation.html">SpecificStatisticalEvaluation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#ade45f4f754ad70161f9c9610966cbbe3">ParseSpecificStatistic</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:ade45f4f754ad70161f9c9610966cbbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a specific statistical evaluation starting at the given index.  <a href="#ade45f4f754ad70161f9c9610966cbbe3">More...</a><br /></td></tr>
<tr class="separator:ade45f4f754ad70161f9c9610966cbbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295f16685a3805120cb13df23a427d20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a295f16685a3805120cb13df23a427d20">ParseStandardFunction</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a295f16685a3805120cb13df23a427d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a standard function starting at the given index.  <a href="#a295f16685a3805120cb13df23a427d20">More...</a><br /></td></tr>
<tr class="separator:a295f16685a3805120cb13df23a427d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa64a1889b71e22fb2c60c166ca6fd5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1Statistic.html">Statistic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#afa64a1889b71e22fb2c60c166ca6fd5a">ParseStatistic</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:afa64a1889b71e22fb2c60c166ca6fd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a statistic starting at the given index.  <a href="#afa64a1889b71e22fb2c60c166ca6fd5a">More...</a><br /></td></tr>
<tr class="separator:afa64a1889b71e22fb2c60c166ca6fd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a271220d101e8108345e63e34c8a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhighprecisionpso_1_1VectorMergeOperation.html">VectorMergeOperation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a08a271220d101e8108345e63e34c8a30">ParseVectorMergeOperation</a> (const std::vector&lt; std::string &gt; &amp;parameters, unsigned int &amp;parsed_parameters)</td></tr>
<tr class="memdesc:a08a271220d101e8108345e63e34c8a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the given vector for a vector merge operation starting at the given index.  <a href="#a08a271220d101e8108345e63e34c8a30">More...</a><br /></td></tr>
<tr class="separator:a08a271220d101e8108345e63e34c8a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9296e54f091bcfb86854d59834a29acf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehighprecisionpso_1_1parse.html#a9296e54f091bcfb86854d59834a29acf">SignalInvalidCommand</a> (const std::vector&lt; std::string &gt; &amp;parameters)</td></tr>
<tr class="memdesc:a9296e54f091bcfb86854d59834a29acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the supplied parameters to stderr and let the program terminate with exit code 1.  <a href="#a9296e54f091bcfb86854d59834a29acf">More...</a><br /></td></tr>
<tr class="separator:a9296e54f091bcfb86854d59834a29acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains a large set of functions for parsing the configuration file. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a1d57511bc5cb2ab1d88862679aba21ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d57511bc5cb2ab1d88862679aba21ab">&#9670;&nbsp;</a></span>ParseCombineFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a>* highprecisionpso::parse::ParseCombineFunction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a combined function starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a combined function. If nothing can be parsed as a combined function then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a combined <a class="el" href="classhighprecisionpso_1_1Function.html" title="This class is an abstract class. It supplies the interface for objective functions. ">Function</a> can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed combined <a class="el" href="classhighprecisionpso_1_1Function.html" title="This class is an abstract class. It supplies the interface for objective functions. ">Function</a> if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="a8dc0dbbbc6c40f55089eff79e2ec004b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc0dbbbc6c40f55089eff79e2ec004b">&#9670;&nbsp;</a></span>ParseCombineSpecificFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1SpecificFunction.html">SpecificFunction</a>* highprecisionpso::parse::ParseCombineSpecificFunction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a combined specific function starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a combined specific function. If nothing can be parsed as a combined specific function then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a combined specific function can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed combined specific function if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="a4eff6b46eb0f12d33ec7fe3a700828f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eff6b46eb0f12d33ec7fe3a700828f7">&#9670;&nbsp;</a></span>ParseCombineSpecificStatistic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1SpecificStatisticalEvaluation.html">SpecificStatisticalEvaluation</a>* highprecisionpso::parse::ParseCombineSpecificStatistic </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a combined specific statistical evaluation starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a combined specific statistical evaluation. If nothing can be parsed as a combined specific statistical evaluation then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a combined specific statistical evaluation can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed combined specific statistical evaluation if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="ab5675e0a8f8de9618eb43f0f94937eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5675e0a8f8de9618eb43f0f94937eb8">&#9670;&nbsp;</a></span>ParseCombineStatistic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Statistic.html">Statistic</a>* highprecisionpso::parse::ParseCombineStatistic </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a combined statistic starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a combined statistic. If nothing can be parsed as a combined statistic then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a combined statistic can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed combined statistic if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="a326060d402a7d760d4a68fa13a714fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326060d402a7d760d4a68fa13a714fce">&#9670;&nbsp;</a></span>ParseConstantEvaluation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1ConstantEvaluation.html">ConstantEvaluation</a>* highprecisionpso::parse::ParseConstantEvaluation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a constant evaluation starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a constant evaluation. If nothing can be parsed as a constant evaluation then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a constant evaluation can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed constant evaluation if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="a9ca1574c91c968ed9d3243c0503cbd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca1574c91c968ed9d3243c0503cbd53">&#9670;&nbsp;</a></span>ParseFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a>* highprecisionpso::parse::ParseFunction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a function starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a function. If nothing can be parsed as a function then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a function can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed function if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="a6a86cb4a3bba8d6dfd4eac01e7c76e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a86cb4a3bba8d6dfd4eac01e7c76e7e">&#9670;&nbsp;</a></span>ParseFunctionMergeOperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a>* highprecisionpso::parse::ParseFunctionMergeOperator </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a function merge operator starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a function merge operator. If nothing can be parsed as a function merge operator then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a function merge operator can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed function merge operator if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="adab564d913e770b264adf000799e7655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab564d913e770b264adf000799e7655">&#9670;&nbsp;</a></span>ParseMergeOperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Statistic.html">Statistic</a>* highprecisionpso::parse::ParseMergeOperator </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a merge operator starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a merge operator. If nothing can be parsed as a merge operator then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a merge operator can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed merge operator if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="a8bb273e1450786a73b0f106367f702ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb273e1450786a73b0f106367f702ff">&#9670;&nbsp;</a></span>ParseModification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Modification.html">Modification</a>* highprecisionpso::parse::ParseModification </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a modification starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a modification. If nothing can be parsed as a modification then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a modification can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed modification if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="ab32c6d497bda5c62401e1a9fa20b851b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32c6d497bda5c62401e1a9fa20b851b">&#9670;&nbsp;</a></span>ParsePairCombinationOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1PairCombinationOperation.html">PairCombinationOperation</a>* highprecisionpso::parse::ParsePairCombinationOperation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a pair combination operation starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a pair combination operation. If nothing can be parsed as a pair combination operation then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a pair combination operation can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed pair combination operation if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="a3423090789ee75111b9e3bd21dd6b78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3423090789ee75111b9e3bd21dd6b78b">&#9670;&nbsp;</a></span>ParseRandomNumberGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1RandomNumberGenerator.html">RandomNumberGenerator</a>* highprecisionpso::parse::ParseRandomNumberGenerator </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a random number generator starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a random number generator. If nothing can be parsed as a random number generator then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a random number generator can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed random number generator if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="a1c556a005a481022a8a7314f22902f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c556a005a481022a8a7314f22902f24">&#9670;&nbsp;</a></span>ParseSpecificFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1SpecificFunction.html">SpecificFunction</a>* highprecisionpso::parse::ParseSpecificFunction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a specific function starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a specific function. If nothing can be parsed as a specific function then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a specific function can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed specific function if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="ade45f4f754ad70161f9c9610966cbbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade45f4f754ad70161f9c9610966cbbe3">&#9670;&nbsp;</a></span>ParseSpecificStatistic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1SpecificStatisticalEvaluation.html">SpecificStatisticalEvaluation</a>* highprecisionpso::parse::ParseSpecificStatistic </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a specific statistical evaluation starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a specific statistical evaluation. If nothing can be parsed as a specific statistical evaluation then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a specific statistical evaluation can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed specific statistical evaluation if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="a295f16685a3805120cb13df23a427d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295f16685a3805120cb13df23a427d20">&#9670;&nbsp;</a></span>ParseStandardFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Function.html">Function</a>* highprecisionpso::parse::ParseStandardFunction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a standard function starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a standard function. If nothing can be parsed as a standard function then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a standard function can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed standard function if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="afa64a1889b71e22fb2c60c166ca6fd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa64a1889b71e22fb2c60c166ca6fd5a">&#9670;&nbsp;</a></span>ParseStatistic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1Statistic.html">Statistic</a>* highprecisionpso::parse::ParseStatistic </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a statistic starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a statistic. If nothing can be parsed as a statistic then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a statistic can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed statistic if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="a08a271220d101e8108345e63e34c8a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a271220d101e8108345e63e34c8a30">&#9670;&nbsp;</a></span>ParseVectorMergeOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhighprecisionpso_1_1VectorMergeOperation.html">VectorMergeOperation</a>* highprecisionpso::parse::ParseVectorMergeOperation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>parsed_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the given vector for a vector merge operation starting at the given index. </p>
<p>The parameter parsed_parameters will store the number of parsed parameters after successful parsing of a vector merge operation. If nothing can be parsed as a vector merge operation then the parameter parsed_parameters will store the initial number of parsed parameters at the time when the function is called. If a vector merge operation can be parsed partially but without success then the parameter parsed_parameters will store the number of elements of the specification vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The vector containing the specification. </td></tr>
    <tr><td class="paramname">parsed_parameters</td><td>The number of already parsed parameters by previous functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parsed vector merge operation if the parsing process was successful and NULL otherwise. </dd></dl>

</div>
</div>
<a id="a9296e54f091bcfb86854d59834a29acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9296e54f091bcfb86854d59834a29acf">&#9670;&nbsp;</a></span>SignalInvalidCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void highprecisionpso::parse::SignalInvalidCommand </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the supplied parameters to stderr and let the program terminate with exit code 1. </p>
<p>This function is called if a command in the configuration file can not be parsed. The supplied command will be printed to stderr with an error message. Finally the function let the program terminate with exit code 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>The command of the configuration file which can not be parsed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 16 2017 15:57:28 for High Precision PSO by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
